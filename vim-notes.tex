\documentclass[a4paper, 12pt]{article}

\usepackage{upquote}

\begin{document}

\title{Vim Notes}
\author{Nazmus Saquib}

\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Help}
\begin{description}
	\item[:help command] shows help for command
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Setting Options}
\begin{description}
	\item[:set number] shows line number
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Saving a File}
\begin{description}
	\item[:w] write
	\item[:w filename] save as given filename
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Qutting Vim}
\begin{description}
	\item[:q] quit
	\item[:wq] write and quit
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Editing}
Every deletion command is a cut command.
\begin{description}
	\item[x] deletes the character under the cursor	
	\item[X] deletes character right behind the cursor
	\item[u] undo
	\item[dw] delete word starting from current letter to end of the current word, repeaters allowed such as 2dw / d2w
	\item[db] deletes previous word, repeaters allowed
	\item[cw] delete the word and put it in insert mode
	\item[dd] delete whole line, repeaters allowed
	\item[dj] delete the current line and the next
	\item[cc] change whole line, repeaters allowed
	\item[ci"] change inside double quotes; works with single quotes, parentheses, curly braces, square brackets.
	\item[ca"]change inside double quotes along with the quotes; works with single quotes, parentheses, curly braces, square brackets.
	\item[y] yank, everything that worked with \emph{d} works with \emph{y}
	\item[p] paste after the cursor, repeaters allowed
	\item[P] paste before the cursor, repeaters allowed
	\item[o] inserts line after the current line
	\item[O] inserts line before the current line
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Indentation}
\begin{description}
	\item[\textgreater\textgreater] one unit of indentation, repeaters allowed
	\item[\textless\textless] removes one unit of indentation, repeaters allowed
	\item[:set list] shows invisible characters, dollar represents newline whereas caret plus capital i represents tab
	\item[:set nolist] hides invisible characters
	\item[:set expandtab] expands tabs to spaces
	\item[:set noexpandtab] converts tabs to spaces
	\item[:set shiftwidth=4] sets tab equal to 4 spaces
	\item[:set smartindent] smart indentation when inserting new line
	\item[=3j] indent 3 lines correctly, works with other movements too
	\item[:set softtabstop=4] sets tabbed indentation length to 4 while in insert mode
	\item[CTRL+t] indent in insert mode
	\item[CTRL+d] remove indentation in insert mode
\end{description}

%------------------------------------------------%
\subsection{indentation in visula line mode}
\begin{itemize}
	\item enter visual line mode by pressing \verb|SHIFT+v|
	\item make selection, if it is needed to go to the first line of selection type \emph{o}
	\item to add indentation type \textgreater, to remove type \textless
	\item to reselect, just type gv
	\item we can use \emph{=} sign for standard indentation
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Folding}
\begin{description}
	\item[zf5j] creates a fold of six lines including the current line and 5 lines below it
	\item[zo] opens fold
	\item[zc] closes fold
	\item[zd] deletes fold
	\item[zi] to go back and forth on opening and closing folds
	\item[:set foldmethod=syntax] folds according to program syntax
	\item[zC] close all folding from where we are
	\item[zO] open all folding from where we are
	\item[:set foldmarker=\{\{\{,\}\}\}] folds based on passed arguments to foldmarker
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Movements}
Repeaters are allowed in \emph{h}, \emph{j}, \emph{k}, \emph{l}.
\begin{description}
	\item[h] move left
	\item[j] move down
	\item[k] move up
	\item[l] move right
	\item[:line-number] jump to the given line number
	\item[w] jump to next word
	\item[b] go back a word
	\item[B] go back a word delimited by whitespace
	\item[W] jump to next word delimited by whitespace
	\item[e] jump to end of next word
	\item[E] jump to end of next word delimited by whitespace
	\item[\$] jump to end of current line
	\item[\^] jump to start of current line
	\item[0] real beginning of the line i.e. does not ignore whitespaces
	\item[gg] jump to beginning of the file
	\item[G] jump to end of the file
\item[\}] jump to the next paragraph
\item[\{] jump to the previous paragraph
	\item[f then a character] go to the first occurrence of character while moving forward
	\item[F then a chracter] move to the first occurrence of charater while moving backward
	\item[t then a character] moves the cursor just before the first occurrence of character while moving forward
	\item[T then a character] moves the cursor just after the first occurrence of character while moving backward
	\item[number t/T/f/F character] find the nth occurrence of the character
	\item[\%] when on one parentheses/curly brace/square bracket, jumps to the matching one
	\item[CTRL+d] jump half a screen down
	\item[CTRL+u] jump half a screen up
	\item[CTRL+f] move one entire screen forward
	\item[CTRL+b] move one entire screen backward
	\item[H] goes to top of the window, repeaters allowed
	\item[M] goes to middle of the window
	\item[L] goes to the bottom of the window, repeaters allowed
	\item[ma] set marker and save at register a
	\item['a] go to marker saved at register a
	\item[''] jumps back where it was
\end{description}

%-------------------------------------------------%
\subsection{Move current Line at different Position of Screen}
\begin{description}
	\item[zt] move current line to top of screen
	\item[zb] move current line to bottom of screen
	\item[z.] move current line to center of screen
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modes}
\begin{description}
	\item[i] insert
	\item[ESC] command mode
	\item[v] visual
	\item[SHIFT+v] visula line
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Searching}
\begin{description}
	\item[/search-term] searches forward
	\item[n] steps to the next match
	\item[N] steps to the previous match
	\item[?search-term] searches backwards, the meaning of \emph{n} and \emph{N} changes accordingly
	\item[:set incsearch] set incremental search, that is searches as each letter is typed
	\item[:set ignorecase] ignores case while searching
	\item[:set hlsearch] highlights the matched words
	\item[:nohlsearch] disables highlight, same as \emph{noh}
	\item[\\n\\n] searches blank lines
\end{description}

\begin{itemize}
	\item vim remembers the recent search, so typing \emph{n} or \emph{N} we can navigate through the matches 
	\item we can also search regular expressions
	\item \emph{d} and then \emph{/search-term} deletes everything from where the cursor is to the first match, also works with \emph{c} and \emph{y}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Substitution}
\begin{description}
	\item[:s/old/new] replace first occurrence of old with new in the current line 
	\item[:\%s/old/new] replace first occurrence of old with new in each line
	\item[:\%s/old/new/g] replace all occurrences of old with new in each line
	\item[:\%s/old/new/c] asks for confirmation before replacing
	\item[:\%s/old/new/i] ignores case
\end{description}

%------------------------------------------------%
\subsection{remove leading whitespace}
\begin{verbatim}
:%s/^\s\+
\end{verbatim}
\begin{itemize}
	\item \emph{\%} is for all lines
	\item first \emph{s} for substitution
	\item \emph{\^} for denoting starting
	\item \emph{\textbackslash s} denotes whitespaces
	\item \emph{\textbackslash +} denotes one or more occurrence
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Buffers}
Current buffer is marked with \emph{\%a} and the previous buffer with \emph{\#} 
\begin{description}
	\item[:ls] shows currently opened buffers	
	\item[:bnext] navigate to the next buffer, same as \emph{:bn}
	\item[:bp] navigate to the previous buffer, works same as \emph{:b\#}; can be used for moving back and forth
	\item[:bf] move to the first buffer
	\item[:bd] delete current buffer
	\item[:bd12] delete buffer number 12
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Windows and Tabs}
\begin{description}
	\item[:split filename] opens file in a horizontal split
	\item[:vsplit filename] opens file in a vertical split
	\item[CTRL+ww] switch among splits
	\item[CTRL+w then h,j,k,l] move among splits
	\item[CTRL+w,SHIFT+l] swap left and right splits
	\item[CTRL+w,+] increases height of split by 1, repeaters allowed
	\item[CTRL+w,-] decreases height of split by 1, repeaters allowed
	\item[CTRL+w,\textgreater] increase width of split by 1, repeaters allowed
	\item[CTRL+w,\textless] decreases width of split by 1, repeaters allowed
	\item[CTRL+w,=] equal distribution of height and width
	\item[:sb2] opens buffer number 2 as horizontal split
	\item[:vert sb2] opens buffer number 2 as vertical split
	\item[:tabedit file] opens file in new tab
	\item[gt] go to next tab
	\item[gT] go to previous tab
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Macros}
Macros are used to execute repeated tasks.
\begin{enumerate}
	\item \emph{q} denotes start of macro recording, also deotes the end	
	\item it is followed by the name of a register, which can be any character or digit
	\item next we carry out a series of commands
	\item after finishing recording, we can execute the macro on a register by using \verb|@regname| syntax
	\item to execute multiple times, we can put a number before \verb|@regname|
	\item if we want to execute the last macro again, we can use \verb|@@|
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Registers}
\begin{description}
	\item[:registers] shows a list of registers	
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{.vimrc File}
The .vimrc file is situated at the home directory. We can save our preferences here. If we want the effect of vimrc to take place immediately without restarting vim, we have to do a \verb|:source ~/.vimrc|.

%-------------------------------------------------%
\subsection{sample vimrc file}
\begin{verbatim}
syntax on
set number
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Command Line}
\begin{description}
	\item[:!command] execute system level command from vim	
	\item[:read !command] put the output of system level command inside vim, \emph{:r} is the short form of \emph{:read}
\end{description}

%-------------------------------------------------%
\subsection{make contents of vim input of a command}
Select bock in visual line mode. then invoke \verb|:!command|

\end{document}
